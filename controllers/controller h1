from controller import Robot

# Constants
WHEEL_RADIUS = 0.0205  # Wheel radius in meters
MAX_SPEED = 6.28  # Maximum speed in rad/s
TARGET_VALUES = [16, 10, 6, 3, 0]  # Red, Yellow, Pink, Brown, Green

# Maze definition (values map to targets)
maze = [
    [24, 22, 22, 19, 18, 17, 16, 11, 10, 9],
    [23, 22, 21, 20, 17, 16, 15, 12, 7, 8],
    [24, 25, 22, 19, 18, 10, 14, 13, 6, 8],
    [25, 24, 23, 6, 5, 2, 1, 0, 5, 6],
    [26, 25, 24, 7, 4, 3, 2, 1, 4, 7],
    [27, 26, 25, 8, 5, 4, 3, 2, 3, 8],
    [29, 27, 10, 9, 7, 8, 10, 3, 3, 5],
    [29, 28, 11, 12, 23, 14, 9, 8, 7, 6],
    [30, 31, 34, 35, 38, 15, 12, 11, 8, 11],
    [33, 32, 33, 36, 37, 16, 13, 10, 9, 10],
]

# Functions for navigation
def find_starting_position():
    for x in range(len(maze)):
        for y in range(len(maze[0])):
            if maze[x][y] != 0:  # Any non-zero value can be the starting point
                return (x, y)

def bfs(maze, start, target):
    rows, cols = len(maze), len(maze[0])
    queue = [(start, [])]  # (current_position, path)
    visited = set()
    
    while queue:
        (x, y), path = queue.pop(0)
        
        if (x, y) in visited:
            continue
        visited.add((x, y))
        path = path + [(x, y)]
        
        if maze[x][y] == target:
            return path
        
        # Explore neighbors
        neighbors = []
        if x > 0: neighbors.append((x - 1, y))  # Up
        if x < rows - 1: neighbors.append((x + 1, y))  # Down
        if y > 0: neighbors.append((x, y - 1))  # Left
        if y < cols - 1: neighbors.append((x, y + 1))  # Right
        
        for nx, ny in neighbors:
            if (nx, ny) not in visited and maze[nx][ny] <= maze[x][y]:  # Only move to lower or equal values
                queue.append(((nx, ny), path))
    
    return []

def calculate_movements(path):
    movements = []
    for i in range(1, len(path)):
        curr_x, curr_y = path[i - 1]
        next_x, next_y = path[i]
        
        if next_x == curr_x and next_y == curr_y + 1:
            movements.append('RIGHT')
        elif next_x == curr_x and next_y == curr_y - 1:
            movements.append('LEFT')
        elif next_x == curr_x + 1 and next_y == curr_y:
            movements.append('DOWN')
        elif next_x == curr_x - 1 and next_y == curr_y:
            movements.append('UP')
    return movements

def execute_movements(robot, movements):
    left_motor = robot.getDevice('left wheel motor')
    right_motor = robot.getDevice('right wheel motor')
    left_motor.setPosition(float('inf'))
    right_motor.setPosition(float('inf'))
    
    for move in movements:
        if move == 'FORWARD':
            left_motor.setVelocity(MAX_SPEED)
            right_motor.setVelocity(MAX_SPEED)
        elif move == 'LEFT':
            left_motor.setVelocity(-MAX_SPEED / 2)
            right_motor.setVelocity(MAX_SPEED / 2)
        elif move == 'RIGHT':
            left_motor.setVelocity(MAX_SPEED / 2)
            right_motor.setVelocity(-MAX_SPEED / 2)
        robot.step(64)
    
    left_motor.setVelocity(0)
    right_motor.setVelocity(0)

# Main program
if __name__ == "__main__":
    robot = Robot()
    timestep = int(robot.getBasicTimeStep())
    
    # Find the starting position dynamically
    start_position = find_starting_position()
    print(f"Starting position: {start_position}")
    
    # Navigate through the target values
    current_position = start_position
    for target in TARGET_VALUES:
        path = bfs(maze, current_position, target)
        print(f"Path to {target}: {path}")
        
        if not path:
            print(f"Cannot reach target {target}")
            break
        
        movements = calculate_movements(path)
        print(f"Movements: {movements}")
        
        execute_movements(robot, movements)
        current_position = path[-1]
    
    print("Completed navigation!")
